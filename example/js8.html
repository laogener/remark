<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<xmp>

    1，栈和队列: 都是普通的数组
    栈: 一端封闭，只能从另一端进出的数组
    何时使用: 总是使用最后进入数组的新元素时。
    特点: FILO
    如何使用:
    1. 结尾出入栈:
    入栈: arr.push(值);
    将值追加到arr末尾
    出栈: var last=arr.pop();
    弹出arr中随后一个元素，保存在last中。
    特点: 每次出入栈不影响其余元素的位置。
    2. 开头出入栈:
    入栈: arr.unshift(值)
    将值插入到arr的开头位置
    出栈: var first=arr.shift();
    弹出arr中开头位置的一个元素,保存在first中。
    特点: 每次出入栈，其他元素的位置都要变化。

    队列: 只能从一头进入，从另一头出
    何时使用: 只要按照先来后到的顺序使用数据时，就要用队列
    特点: FIFO
    如何使用: 从结尾入队列，从开头出队列
    1. 从结尾入队列: arr.push(值);
    2. 从开头出队列:
    var first=arr.shift();


    2， ***String:
    什么是: 由多个字符组成的只读字符数组
    vs 数组:
    相同: 1.可用下标访问每个字符
    2.都有length属性表示字符个数
    3.数组中，凡是不直接修改原数组的API，字符串，都可用，比如:     slice

    概念:内置对象: ES标准中规定的，浏览器厂商已经实现的对象。
    包括:11个
    String Number Boolean
    Array Date Math RegExp
    Error
    Function Object
    Global(在浏览器中被window取代)


    3， ***String API: 所有字符串的API都无权修改原字符串，只能返回新字符串

    大小写转换:
    何时使用:只要不区分大小写
    str.toUpperCase(); //转大写
    str.toLowerCase(); //转小写


    4， 包装类型:专门封装原始类型的值，并提供对原始类型的值进行操作的API。
    为什么:原始类型的值，不包含任何方法
    但是，开发中又经常对原始类型的值执行类型的操作。
    如何使用: 不用主动使用!
    试图用原始类型的值调用方法时，都会自动创建该类型对象的包装类型对象
    比如:n.toFixed(2)
    ->new Number(n).toFixed(2)
    c.charCodeAt();
    ->new String(c).charCodeAt();
    生命周期: 调用完方法后，立刻销毁。


    5， 调用API排序: arr.sort();
    问题:sort默认会将所有元素临时转为字符串，按字符串排序。
    所以，只有在按字符串排序时，才可直接使用sort方法。
    解决:自定义比较器函数:
    比较器函数: 专门比较任意两数大小的函数。
    要求: 通过返回值的正负，标识两个数的大小。
    参数: a,b
    如果a>b，返回正数
    如果a<b，返回负数
    如果a=b, 返回0
    如何使用比较器函数: 2步:
    1. 定义比较器函数
    function compare(a,b){
    return a-b;
    }
    2. 将比较器函数传入sort方法中作为参数。
    arr.sort(compare);
    何时使用: 只要默认的sort排序规则不是想要的，就都要自定义比较器函数。

    补: 创建函数: 2种:
    1. 声明方式：会被声明提前
    function 函数名(参数列表){...}
    2. 函数直接量: 不会被声明提前
    var 函数名=function(参数列表){...}
    揭示: 函数其实是一个对象
    函数名其实仅是一个引用函数对象的变量。

    降序比较器:
    function compare(a,b){return b-a;} 调用API排序: arr.sort();
    问题:sort默认会将所有元素临时转为字符串，按字符串排序。
    所以，只有在按字符串排序时，才可直接使用sort方法。
    解决:自定义比较器函数:
    比较器函数: 专门比较任意两数大小的函数。
    要求: 通过返回值的正负，标识两个数的大小。
    参数: a,b
    如果a>b，返回正数
    如果a<b，返回负数
    如果a=b, 返回0
    如何使用比较器函数: 2步:
    1. 定义比较器函数
    function compare(a,b){
    return a-b;
    }
    2. 将比较器函数传入sort方法中作为参数。
    arr.sort(compare);
    何时使用: 只要默认的sort排序规则不是想要的，就都要自定义比较器函数。

    补: 创建函数: 2种:
    1. 声明方式：会被声明提前
    function 函数名(参数列表){...}
    2. 函数直接量: 不会被声明提前
    var 函数名=function(参数列表){...}
    揭示: 函数其实是一个对象
    函数名其实仅是一个引用函数对象的变量。

    降序比较器:
    function compare(a,b){return b-a;}


    6, *****OOP
    什么是面向对象: 程序中都是用对象描述现实中一个具体事物。
    对象: 用途:程序中专门描述现实中一个事物的结构。
    存储:内存中同时存储多个数据的一块存储空间。
    为什么面向对象:现实中一个数据都要包含在一个具体的事物中，才有意义。
    三大特点: 封装 继承 多态
    如何使用面向对象: 2步:
    1.创建对象:来封装现实中一个具体事物的属性和功能。------封装
    事物的属性，会成为对象的属性
    事物的功能，会成为对象的方法
    也叫  *封装*      :将对象的属性和方法集中定义在一个对象中！
    1.对象直接量:
    var obj={
    "属性名":属性值,
    "...":...,
    "方法名":function(){
    ...
    },
    "...":function(){
    }
    }
    ***js中一切都是对象，一切对象底层都是hash数组。
    2.使用new关键字:
    var obj=new Object();//{}
    obj.属性名=值;
    obj.方法名=function(...){...};
    *****3.使用构造函数反复创建相同结构的对
    :
    象：
    什么是构造函数:专门描述一类对象的统一结构的函数。
    何时使用:只要反复创建多个结构相同的对象时，都要用构造函数创建
    为什么:代码重用！
    如何使用:2步:
    1.定义构造函数，描述一类对象的统一结构。
    function 类型名(属性变量,...){
    this.属性名=属性变量值;
    this....=...;
    this.方法名=function(){...}
    } 
    2.使用new调用构造函数，创建新对象
    var obj=new 类型名(属性值,...);

    2. 按照逻辑顺序，依次调用对象的方法，操作对象的属性值。
    访问对象的属性:
    obj.属性名 或 obj["属性名"]
    .读作“的”
    对象中每个属性的用法和普通的变量完全一样。
    调用对象的方法: obj.方法名()
    每个方法的用法和普通的函数完全一样

    obj vs hash:
    相同点:
    1. 都可用下标名称访问属性
    2. 也用for in遍历对象的每个属性
    3. 也可随时添加新的属性和方法
    4. 访问对象中不存在的属性，不会报错，只会返回undefined

    *****this:
    在对象的方法内，引用正在调用函数的对象的关键字。（就是.前的对象）
    读作:"当前对象"

    *****继承: 父对象的成员(属性+方法)，子对象不用重复创建，就可直接使用！
    为什么继承: 代码重用，节约内容——优点
    原型对象: 专门保存一类子对象，共有成员的父对象。
    原型对象不用手动创建！
    如何访问:
    1.构造函数.prototype
    2.子对象.__proto__
    child.__proto__ 内部属性
    Object.getPrototypeOf(obj)
    获得obj的父级原型对象。
    何时使用原型对象:今后，只要所有子对象，公用的属性和方法，都要放在原型对象中。
    原型链(prototype chain):由各级父对象的__proto__属性，逐级继承，形成的链式结果

    原型链控制着对象的属性的使用顺序:
    优先使用当前对象本地的属性——自有属性

    如果自己没有，则延原型链向父级查找。
    如果整个原型链上都没有，才返回undefined
    vs 作用域链:控制函数中变量的使用顺序
    通常，作用域链中只包含两种对象:函数作用域(AO)和全局作用域(window)
    利用原型链:
    1. 今后，只要所有子对象共有的属性和方法，都要集中定义在原型对象中。
    2.为内置对象，扩展新属性——解决浏览器兼容性问题。

    强调：js中的继承都是通过原型对象实现的
    ——也成为原型继承
    继承API:
    1.获得原型对象:3种:
    1.通过构造函数获得:
    构造函数.prototype
    2.通过子对象获得:
    child.__proto__ 内部属性
    Object.getPrototypeOf(obj)
    获得obj的父级原型对象。
    2.自有属性和共有属性:
    自有属性: 直接保存在当前对象本地的属性.
    构造函数中，凡是this.添加的属性都是自有属性。
    修改自有属性，不影响其他子对象。
    共有属性: 保存在原型链上的父对象中的属性。
    定义在原型对象中的属性，都是共有属性
    修改共有属性，会影响其他子对象。
    判断:
    自有属性: 判断"属性名"是否直接保存在obj对象本地。
    var bool=obj.hasOwnProperty("属性名");
    如果"属性名"是obj的自有属性，就返回true，否则，返回false。
    共有属性: 不是自有，而且在原型链上有
    !obj.hasOwnProperty("属性名")&&(obj.属性名!==undefined)
    判断原型链上是否包含指定属性:
    1.obj.属性名!==undefined
    2.var bool= "属性名" in obj
    判断obj的原型链上是否包含指定属性

    修改属性: 一般属性定义在哪儿，就用哪个对象修改该属性的值:
    修改自有属性: obj.属性名=值;
    修改共有属性: 构造函数.prototype.属性名=值
    强行用子对象，修改原型对象中的属性:

    删除对象的属性: delete obj.属性名
    只能删除自有属性。
    要删除共有属性，必须删除原型对象的属性。

    多态:同一个方法，在不同时刻，表现出不同的状态。
    重写(override):如果子对象觉得父对象继承来的方法不好用，可在本地定义同名自有方法，覆盖父对象的方法。
    为什么:为了体现子对象和父对象之间的差异！


    1. *****OOP
    自定义继承:
    1.只是修改两个对象间的继承:
    js中的继承都是通过原型对象实现的
    只要修改子对象的原型属性即可更改继承
    为什么:如果一个对象，希望直接继承另一个对象中的成员时，就可自定义继承关系。
    如何修改:
    child.__proto__=father 内部属性
    Object.setPrototypeOf(child,father)
    让child继承father
    2.修改构造函数的原型对象，实现批量修改所有子对象的继承关系。
    构造函数.prototype=father
    强调:时机:必须在创建第一个子对象前就修改。
    *****3.两种类型间的继承:最像Java的继承
    抽象:使用构造函数统一定义一类对象的相同结构。
    重构:如果多个类型的构造函数或原型对象，拥有相同的成员或共有属性，就都要将相同的成员或共有属性集中定义在一个父类型中。
    何时使用: 如果多个子类型拥有相同的成员或共有属性时，都要抽象出公共的父类型。
    如何使用: 2步:
    1.借用父类型构造函数，为子类型对象添加统一的结构。——extends扩展
    2.让子类型的原型对象，继承父类型的原型对象。——inherits继承

    call和apply
    相同:借用函数，强行更改函数内的this为指定的对象。
    何时使用:只要函数中的默认的this的对象不是想要的，就可用call或apply替换this的对象
    如何使用:
    call:
    函数.call(替换this的对象,参数1，参数2，)
    apply:
    函数.call(替换this的对象,[参数1,参数2,])

    2. *****ES5
    对象的属性:
    对象，其实就是一组属性的集合
    对象属性分两大类:
    命名属性:可以通过对象.访问到的属性
    数据属性:专门保存一个数据的属性
    访问器属性:？
    内部属性:不允许通过对象.直接访问的属性。

    数据属性:
    旧: 对象.属性=值;
    问题: 属性可被任意读取和修改
    可被随意删除
    ES5: 对象的属性增加了四大特性:
    value:实际保存属性值
    writable:true/false 控制是否只读
    enumerable:true/false 控制是否能用for in遍历到
    configurable:true/false 控制：
    1.能否修改其他特性
    2.能否删除该属性

    命名属性：可直接用对象.方式访问的属性
    数据属性: 保存一个属性值的属性
    四大特性:
    value:实际保存属性值
    writable:true/false，控制是否只读
    enumerable:true/false，控制能否被for in遍历到
    configurable:true/false，控制:
    1. 能否修改其他特性
    2. 能否删除该属性
    获取四大特性:
    var 包含四大特性的对象=
    Object.getOwnPropertyDescriptor(
    obj,"属性名"
    )
    设置一个属性的四大特性:
    Object.defineProperty(obj,"属性"{
    特性:值,
    ...:...
    })
    不但可修改现有属性的特性，而且还可添加新的属性，并设置其特性。

    ***四大特性的默认值:
    1.对象直接量添加的属性，属性的特性默认值都是true!
    2.如果是使用defineProperty方法添加的属性，特性的默认值一律是false！

    访问器属性:可自定义保护逻辑的属性。
    何时使用:只要属性的值，需要经过逻辑判断才能修改时。
    如何使用:访问器属性不直接保存属性值
    四大特性:
    get:function(){return 属性的值}
    访问对象.属性时，自动调用get方法
    set:function(value){
    经过判断后，将value赋值给属性
    }
    试图给对象.属性=值,自动调用set方法，其中"值"，会被传给value。
    enumerable:
    configurable:

    访问器属性，只能通过	      Object.defineProperty添加
    Object.defineProperty(obj,"属性",{
    get:function(){
    return 受保护的变量值
    },
    set:function(value){
    //如果value不满足条件
    //报错
    //否则，就将value赋值给受保护的变量。
    },
    enumerable:true,
    configurable:true
    })
    访问:obj.属性时，自动调get方法
    obj.属性=值, 自动调set，参数value会自动的到"值"
    特殊: 如果访问器属性没有提供set方法，则该属性为只读属性。

    一次定义多个属性:
    Object.defineProperties(obj,{
    属性名1:{四大特性},
    属性名2:{四大特性},
    ...:...
    })
    vs Java:
    private:无法通过对象.访问的属性
    其实构造函数中的受保护的局部变量都可以看做私有属性。
    每个私有属性都要受一个公有的访问器属性保护。
    public:可以通过对象.访问的属性
    其实，凡是直接用this.添加的属性，就是公有属性。

    鄙视题：定义一个类型，同时包含私有属性和公有属性：见4_getter_setter.html

    内部属性:
    __proto__:引用当前对象的父对象
    class:保存对象创建时的类型名
    Extensible:表示当前对象是否可扩展。

    防篡改:限制对对象或对象的属性执行配置
    以下操作，不可逆！
    1.防扩展:禁止对对象添加新的属性
    如何防扩展:
    Object.preventExtensions(obj)
    禁止为obj添加新的属性
    其实:将obj的extensible属性改为false
    2.密封:在防扩展的基础上，再禁止修改现有属性的特性
    如何密封:
    Object.seal(obj);
    其实:将obj的extensible属性改为false
    将每个属性的configurable都改为false
    3.冻结:不允许对对象做任何修改！
    如何冻结:
    Object.freeze(obj)
    其实:将obj的extensible属性改为false
    将每个属性的configurable都改为false
    将所有属性的writable改为false



    1. Object.create():
    何时使用:希望基于一个现有父对象，创建一个子对象，并扩展自有属性时。
    如何使用:
    var child=Object.create(father,{
    新属性1:{四大特性},
    ...:...
    })
    实现原理:见1_objectCreate.html

    2. 数组API:
    判断: 整个数组中的元素，是否满足要求
    arr.every(判断条件):
    如果arr中所有元素都符合判断条件的要求，才返回true
    只要有一个元素不符合，就返回false
    arr.some(判断条件):
    只要任意一个元素符合判断条件的要求，就返回true，
    除非所有元素都不符合判断条件的要求才返回false。
    其中:参数判断条件:
    function(value,index,arr){
    return true/false;
    }
    执行原理：用条件函数，依次到每个元素上执行一次。value获得当前元素的值
    index获得当前元素的位置
    arr获得当前数组
    何时使用: 只要判断一个数组中每个元素是否符合要求时

    迭代:依次对数组中每个元素执行相同的操作。
    arr.forEach(对每个元素的操作):
    对原数组中每个元素，执行相同的操作
    直接修改原数组，不返回新数组
    arr.map(对每个元素的操作):
    依次取出原数组中每个元素的值，执行相同的操作后，放入新数组中
    一般不直接修改原数组，而是返回新数组对象。
    其中:参数:对每个元素的操作
    function(val,idx,arr){
    //forEach
    arr[idx]=?;
    //map
    return 新值;
    }
    何时使用:只要对数组中每个元素执行相同的操作

    过滤:仅筛选出原数组中符合判断条件的元素，组成新数组。
    强调：原数组保持不变
    如何使用:
    var subArr=arr.filter(
    function(val,idx,arr){
    return true/false;
    }
    );

    汇总:将数组中每个元素的值，汇总出一个结果。
    如何使用:
    var r=arr.reduce(
    function(prev,val,idx,arr){
    return 截止到idx位置的汇总值
    },
    startPrev//默认为0
    )
    其中,prev保存的是idx位置之前的汇总值
    val保存的是当前值
    startPrev:预定义的汇总开始值

    3.严格模式：
    　 如何启用:
    在代码段开头: "use strict";
    如果写在<script>的开头，表示整个script都采用严格模式。
其实也可写在一个函数的开头，表示仅函数内的代码启用严格模式
规则:
    1. 静默失败,升级为错误！
比如: const PI=3.14;
PI=1.14;
2. 不允许给未声明过的变量赋值
3. 禁止删除不允许删除的属性
4. 增加了eval作用域:
    在eval内声明的变量，eval后不可访问。
5. 禁止使用arguments的callee执行递归调用。

*****fun.bind()
什么是:基于一个现有函数，创建一个新函数，同时提前绑定函数中的this为指定对象。
何时使用: 今后只要希望将一个对象和一个函数中的this，永久绑定，只能用bind。
原理：
1. 创建了一个新函数
2. 在新函数中调用了原函数
3. 永久绑定函数中的this为指定对象。
基本用法:
    var fun1=fun.bind(obj);
基于fun创建一个新函数fun1，并永久绑定fun1中的this为obj
高级用法:
    var fun1=fun.bind(obj,参数1,...)
基于fun创建一个新函数fun1，并永久绑定fun1中的this为obj,同时永久绑定fun1中的参数值为参数1,....

鄙视题:
    call apply bind
call apply：IE8+
相同点:临时*借(调)用函数*，临时替换函数中的this为指定对象。    不同点:传递给借用的函数的参数：
call，要求每个参数独立传入
apply,要求所有参数用数组或集合方式整体传入。
强调: 不创建新函数，而是直接调用原函数。
bind: IE9+
相同:都是为了替换函数中的this为指定对象。
不同:
    1.*创建一个新函数*。
2.永久绑定this为指定对象，且也可永久绑定部分参数值。

模拟实现bind函数









</xmp>
</body>
</html>