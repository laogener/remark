<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<xmp>
    1， arr to string: 2种:
    1. 拍照: var str=String(arr);
    输出arr中每个元素的内容，默认以逗号分隔每个元素。
    2. 自定义连接符:
    var str=arr.join("连接符");
    固定套路:
    1. 字符数组拼接为单词:
    var word=chars.join("");
    强调: 1. .join()==>String(arr)
    2. 无缝拼接必须加""
    2. 将单词拼接为英文句子:
    var stmt=words.join(" ");
    3. 将数组拼接为页面元素:

    2，  拼接和截取，插入，删除:
    1、concat: 拼接
    var newArr=arr1.concat(arr2);
    将arr2中的元素，拼接到arr1之后
    强调: concat不会直接修改arr1和arr2
    只会重新创建一个更大的新数组
    其实参数可以混搭:
    .concat(值1,值2,arr2,值3,...)
    2、slice: 截取:
    var subArr=arr.slice(starti,endi+1);
    复制出arr中starti位置到endi位置的元素，组成新的子数组。
    强调：不改变原数组，只返回新的子数组。
    含头不含尾！
    支持负数参数: arr.slice(-n,-m)
    截取倒数第n个开始，到倒数第m个之前截止的元素。
    其实：arr.slice(arr.length-n,
    arr.length-m);

    3、splice: 删除 插入 替换——直接修改原数组
    删除:[var deletes=]arr.splice(starti,n)
    删除arr中starti位置开始后的n个元素
    不必考虑含头不含尾
    其实被删除的元素会组成新数组返回
    如果被删除的元素还有用，可用变量接住返回值。
    插入:arr.splice(starti,0,值1,值2,...)
    将值1,值2,...插入到arr中starti位置
    原starti位置及其之后的值向后挤压
    不支持数组参数:无法打散参数数组
    替换: [var deletes=]
    arr.splice(starti,n,值1,值2,...)
    删除arr中starti开始后的n个元素，再在starti位置，插入值1,值2,
    删除的元素个数和插入的新元素个数可以不相等。js会自动调整数组的容量。

    翻转数组: arr.reverse();排序arr.sort();
    4，split:切割: 按指定的字符，将字符串，切割为多个子字符串。
    var subs=str.split("分隔符")
    str.split(reg)
    返回值: 包含切割后所有子字符串的数组
    在返回的数组中，不再包含分隔符。
    何时使用: 今后，只要分段处理字符串时
    都要先切割，再分段处理每个字字符串
    最后再拼接起来。
    固定套路:
    1. 将字符串，打散成字符数组:
    var chars=str.split("");
    2. 将英文的句子打散成单词:
    var words=stmt.split(" ");
    3. 将页面元素的内容，切割为子数组:

    5，字符串中的操作
    获取指定位置的字符: str[i]
    var char=str.charAt(i)
    获得str中i位置的1个字符
    获得指定位置的字符的unicode号
    var unicode=str.charCodeAt(i)
    将unicode转回char:
    var char=String.fromCharCode(uc);

    获取子字符串:
    var subStr=str.slice(starti,endi+1);
    str.substring(starti,endi+1);
    同样，含头不含尾
    不同: slice可用负数参数
    substring不支持负数参数
    变通: length-n 倒数n个
    str.substr(starti,n)
    截取str中starti位置开始后的n个字符。不用考虑含头不含尾
    如果省略第二个参数n，表示
    从i开始截取剩余的所有字符



    1.*****正则表达式
    什么是: 专门规定字符串中字符出现规律的表达式
    何时使用: 查找 替换 验证
    如何使用:
    1.最简单的正则表达式就是关键词的原文
    2.字符集: 规定字符串中某*一位*字符备选字符列表的规则。
    如何使用:[备选字符列表]
    特殊:
    1. 如果备选字符列表中包含部分unicode练习的字符，可用-省略中间的字符:
    比如: 匹配1位大写字母: [A-Z]
    1位数字:[0-9]
    1位小写字母:[a-z]
    1位字母:[A-Za-z]
    1位汉字:[\u4e00-\u9fa5]
    2. 表示除xxx之外都行:
    [^47] 除了4和7之外都行
    3. 预定义字符集: 对常用字符集的简化
    1位数字: \d ==>[0-9]
    1位字母，数字或_:
    \w ==>[a-zA-Z0-9_]
    1位空字符: \s 空格，制表符，换行

    1位任意字符: . 除换行外，一切字符
    4. 量词: 专门规定字符集出现次数的规则
    如何使用: 用于一个字符集之后，修改前一个相邻字符出现的次数
    有明确数量:
    {n,m} 至少n次，最多m次
    {n,} 至少n次，多了不限
    {n}  必须n次，不能多也不能少

    不明确数量:
    ? 可有可无，最多1次
    * 可有可无，多了不限
    + 至少1次，多了不限
    5. 选择和分组:
    选择: 或 | 在两个表达式中二选一匹配
    分组: 将多个字符集用()，标记为一组
    何时使用: 希望一个量词同时修饰多个字符集时，就要将多个字符集先分组。
    手机号:
    +86或0086 可有可无，最多1次
    空字符    至少一个，多了不限
    1
    在3,4,5,7,8之中挑一个
    9位数字
    (\+86|0086)?\s+1[34578]\d{9}
    6.指定匹配位置:
    字符串开头: ^ 比如: 开头的空字符
    字符串结尾: $ 比如: 结尾的空字符
    固定套路:
    如果希望从头到尾必须完整匹配时，就要同时前加^,后加$——验证
    例外:^\s+|\s+$ 不是从头到尾完整匹配
    因为|优先级最低，到时正则被一分为二
    单词的边界: \b

    需求: 密码强度验证
    6~8位，字母，数字的组合，至少包含一位大写字母和一位数字
    预判: 在正式匹配之前，先浏览整个表达式，是否符合指定的规则
    (?规则$)
    1. 预判从头到尾不全由字母组成:
    说明: 至少包含一位数字或特殊符号
    (?![a-zA-Z]+$)
    2. 预判从头到尾不全由数字和小写字母组成
    说明: 至少包含一位大写字母或特殊符号
    (?![a-z0-9]+$)
    3. 必须是6~8位字母和数字的组合
    ^(?![a-zA-Z]+$)(?![a-z0-9]+$)[a-zA-Z0-9]{6,8}$

    6，查找关键词:
    4种:(主要用于正则表达式中)
    1. 查找一个固定关键词的位置:
    var i=str.indexOf("关键词",fromi);
    从str中fromi位置开始，查找下一个"关键词"在str中的位置
    省略第二个参数，默认从0开始查找
    返回值: 仅返回下一个关键词的位置i
    如果没找到，返回-1
    var i=str.lastIndexOf("关键词",fromi)
    从str中fromi位置开始，查找前一个"关键词"在str中的位置
    省略第二个参数，默认从最后开始查找
    返回值:同indexOf
    缺: 不支持正则！
    问题: 一次只能查找一个固定的关键词
    解决: 使用支持正则表达式的查找API
    3个:
    2. 判断是否包含满足正则要求的关键词:
    var i=str.search(reg);
    在str中查找第一个和reg匹配的关键词的位置。
    如果找不到，返回-1。
    其中，reg是一个正则表达式对象:
    var reg=/正则表达式/;
    创建一个正则表达式对象。
    强调: search没有第二个参数，所以，不能指定开始查找的位置。永远只能找第一个。
    何时使用: 只判断有没有时。
    缺: 永远只能找第一个，只能返回位置，无法返回内容
    3.获得每个关键词的内容:
    var kwords=str.match(reg);
    获取str中reg匹配的所有关键词，保存在数组kwords中。
    强调: 如果希望找到所有关键词:
    var reg=/正则/ig;
    其中: i 忽略大小写
    g 查找全部关键词
    如果不加后缀: 默认区分大小的，而且只能找第一个
    特殊:
    1.***如果没找到，返回null！
    都要先判断不是null，再使用！
    2.如果reg不加g,仅查找第一个关键词:
    返回: [
    0:第一个关键词的内容,
    index:第一个关键词的位置
    ]
    问题: 只能查找关键词的内容，无法获得每个关键词的位置。
    4. 即获得每个关键词的内容，又获得每个关键词的位置:
    var arr=reg.exec(str);
    使用exec时，reg的结尾必须加g
    用reg，去str中依次查找每个关键词的内容和位置。
    问题:一次，也只能找下*一个*关键词
    解决:用循环，反复调用reg.exec
    原理:
    reg对象，内部有一个lastIndex属性记录了下次开始匹配的位置。默认          为0
    exec每次从reg的lastIndex属性记录的位置开始，查找下一个关键词的位        置和内容
    返回: arr:["kword","$1",...]
    [0]     [1]
    arr.index: 记录了找到的关键词的位置。
    exec每次查找完都会自动将reg的lastIndex属性移动到当前关键词之后           。
    如果找不到，则返回null

    5.  替换: str=str.replace(reg,"替换值");
    将str中reg匹配的关键词替换为指定的"替换值"
    强调: reg后加g，替换所有
    不加g，仅替换第一个
    完整版的replace:
    str=str.replace(reg,function(kw){
    //处理逻辑;
    return "替换值";
    })
    其中,kw会自动获得每次找到的当前关键词
    函数体中，可根据当前关键词，执行处理，最后返回对应的替换值

    衍生功能:
    删除关键词：str.replace(reg,"");
    格式化: 2步:
    1. 使用分组，将原字符串按照格式需要分割。
    比如: 19831226
    (\d{4})(\d{2})(\d{2})
    1      2      3
    强调: 在匹配时，每个分组都会自动获得一个序号:
    2. 使用replace方法，在替换时，分别获得每个分组的内容，再拼接格式。
    str.replace(reg,"$1年$2月$3日");
    其中:$n会自动匹配第n个分组的子字符串
    6. 验证: 检查一段字符串是否和正则表达式完全匹配。
    如何验证: var bool=reg.test(str);
    检查str是否和reg完全匹配
    如果验证通过，返回true
    否则返回false。
    强调: 验证功能中,正则表达式必须前加^，后加$。
    如果不加，只要部分匹配，就为true。
    不用加g后缀，因为只匹配一次。



</xmp>
</body>
</html>